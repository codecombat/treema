{"version":3,"file":"treema-utils.js","sources":["src/utils.coffee"],"names":[],"mappings":"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","sourcesContent":["(->\n  \n  utils = {}\n  \n  utils.populateDefaults = (rootData, rootSchema, tv4) ->\n    if rootSchema.default and not rootData\n      rootData = @cloneDeep(rootSchema.default)\n      \n    @walk rootData, rootSchema, tv4, (path, data, schema) =>\n      def = schema.default\n      return unless @type(def) is 'object' and @type(data) is 'object'\n      for key, value of def\n        data[key] ?= @cloneDeep(value)\n        \n    rootData\n    \n  utils.populateRequireds = (rootData, rootSchema, tv4) ->\n    rootData ?= {}\n\n    @walk rootData, rootSchema, tv4, (path, data, schema) =>\n      return unless schema.required and @type(data) is 'object'\n      for key in schema.required\n        continue if data[key]?\n        if schemaDefault = schema.default?[key]\n          data[key] = @cloneDeep(schemaDefault)\n        else\n          childSchema = @getChildSchema(key, schema)\n          workingSchema = @buildWorkingSchemas(childSchema, tv4)[0]\n          schemaDefault = workingSchema.default\n          if schemaDefault?\n            data[key] = @cloneDeep(schemaDefault)\n          else\n            type = workingSchema.type\n            if @type(type) is 'array' then type = type[0]\n            if not type then type = 'string'\n            data[key] = TreemaNode.defaultForType(type)\n\n    rootData\n  \n  utils.walk = (data, schema, tv4, callback, path='') ->\n    if not tv4\n      tv4 = @getGlobalTv4().freshApi()\n      tv4.addSchema('#', schema)\n      tv4.addSchema(schema.id, schema) if schema.id\n    \n    workingSchemas = @buildWorkingSchemas(schema, tv4)\n    workingSchema = @chooseWorkingSchema(data, workingSchemas, tv4)\n    \n    callback(path, data, workingSchema)\n    \n    # this actually works for both arrays and objects...\n    if @type(data) in ['array', 'object']\n      for key, value of data\n        childPath = path.slice()\n        childPath += '.' if childPath\n        childPath += key\n        childSchema = @getChildSchema(key, workingSchema)\n        @walk(value, childSchema, tv4, callback, childPath)\n  \n  utils.getChildSchema = (key, schema) ->\n    if @type(key) is 'string'\n      for childKey, childSchema of schema.properties\n        if childKey is key\n          return childSchema \n      for childKey, childSchema of schema.patternProperties\n        if key.match(new RegExp(childKey))\n          return childSchema\n      if typeof schema.additionalProperties is 'object'\n        return schema.additionalProperties \n        \n    if @type(key) is 'number'\n      index = key\n      if schema.items\n        if Array.isArray(schema.items)\n          if index < schema.items.length\n            return schema.items[index]\n          else if schema.additionalItems\n            return schema.additionalItems\n        else if schema.items\n          return schema.items\n  \n    return {}\n  \n  # Working schemas -----------------------------------------------------------\n  \n  # Schemas can be flexible using combinatorial properties and references.\n  # But it simplifies logic if schema props like $ref, allOf, anyOf, and oneOf\n  # are flattened into a list of more straightforward user choices.\n  # These simplifications are called working schemas.\n  \n  utils.buildWorkingSchemas = (schema, tv4) ->\n    schema ?= {}\n    baseSchema = @resolveReference(schema, tv4)\n    return [schema] unless schema.allOf or schema.anyOf or schema.oneOf\n    baseSchema = @cloneSchema(baseSchema)\n    allOf = baseSchema.allOf\n    anyOf = baseSchema.anyOf\n    oneOf = baseSchema.oneOf\n    delete baseSchema.allOf if baseSchema.allOf?\n    delete baseSchema.anyOf if baseSchema.anyOf?\n    delete baseSchema.oneOf if baseSchema.oneOf?\n  \n    if allOf?\n      for schema in allOf\n        @combineSchemas baseSchema, @resolveReference(schema, tv4)\n  \n    workingSchemas = []\n    singularSchemas = []\n    singularSchemas = singularSchemas.concat(anyOf) if anyOf?\n    singularSchemas = singularSchemas.concat(oneOf) if oneOf?\n  \n    for singularSchema in singularSchemas\n      singularSchema = @resolveReference(singularSchema, tv4)\n      newBase = @cloneSchema(baseSchema)\n      @combineSchemas(newBase, singularSchema)\n      workingSchemas.push(newBase)\n      \n    workingSchemas = [baseSchema] if workingSchemas.length is 0\n    workingSchemas\n  \n  utils.chooseWorkingSchema = (data, workingSchemas, tv4) ->\n    return workingSchemas[0] if workingSchemas.length is 1\n    tv4 ?= @getGlobalTv4()\n    for schema in workingSchemas\n      result = tv4.validateMultiple(data, schema)\n      return schema if result.valid\n    return workingSchemas[0]\n  \n  utils.resolveReference = (schema, tv4, scrubTitle=false) ->\n    return schema unless schema.$ref?\n    tv4 ?= @getGlobalTv4()\n    resolved = tv4.getSchema(schema.$ref)\n    unless resolved\n      console.warn('could not resolve reference', schema.$ref, tv4.getMissingUris())\n    resolved ?= {}\n    delete resolved.title if scrubTitle and resolved.title?\n    resolved\n  \n  utils.getGlobalTv4 = ->\n    if typeof window isnt 'undefined'\n      return window.tv4\n    if typeof global isnt 'undefined'\n      return global.tv4\n  \n  # UTILITY UTILITIES\n  # Normally I'd use jQuery or lodash for most of these, but this file should be completely library/context agnostic.\n  # These are fairly simplified because data is assumed to not include non-plain objects.\n  \n  utils.cloneSchema = (schema) ->\n    clone = {}\n    clone[key] = value for key, value of schema\n    clone\n  \n  utils.combineSchemas = (schema1, schema2) ->\n    for key, value of schema2\n      schema1[key] = value \n    schema1\n    \n  utils.cloneDeep = (data) ->\n    clone = data\n    type = @type(data)\n    if type is 'object'\n      clone = {}\n    if type is 'array'\n      clone = []\n    if type in ['object', 'array']\n      for key, value of data\n        clone[key] = @cloneDeep(value)\n    return clone\n  \n  # http://arcturo.github.io/library/coffeescript/07_the_bad_parts.html\n  utils.type = do ->\n    classToType = {}\n    for name in \"Boolean Number String Function Array Date RegExp Undefined Null\".split(\" \")\n      classToType[\"[object \" + name + \"]\"] = name.toLowerCase()\n  \n    (obj) ->\n      strType = Object::toString.call(obj)\n      classToType[strType] or \"object\"\n\n  utils.defaultForType = (type) ->\n    {string:'', number:0, null: null, object: {}, integer: 0, boolean: false, array:[]}[type]\n    \n  # Export either to TreemaNode if it exists, or to module.exports for node\n\n  if typeof TreemaNode isnt 'undefined'\n    TreemaNode.utils = utils\n\n  if typeof module isnt 'undefined' and module.exports\n    module.exports = utils\n\n)()\n"]}